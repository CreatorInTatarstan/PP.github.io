<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.24.1/themes/prism.min.css">
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.24.1/prism.min.js"></script>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        Prism.highlightAll();
    });
</script>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>CSS</title>
  <link rel="stylesheet" type="text/css" href="main_styleCSS.css">
 
</head>
<body>
  <div class="cap">
    <div class="logo"><font color="orange">&lt;/&gt; Html</font>School</div>
    <div class="content">
      <a class="mainBtn1" href="/index.html">Главная</a> 
      <a class="mainBtn" href="">Самостоятельная работа</a>
      <a class="mainBtn" href="">Поддержка</a>
      <a class="mainBtn" href="/контакты/contacts.html">Контакты</a>
    </div>
  </div>

<div class="nach">
  <a name="#top"></a><font color="orange">CSS</font>
</div>
<div class="block">

    <div class="info">
      <input id="info__body_1" class="info__switch" type="checkbox">
      <label id="info__body_1" for="info__body_1" class="info__headline">Знакомство с <font color="orange" >CSS</font></label>
      <div class="info__body">
       <p><font color="orange" >CSS</font> является сложным языком, который отнимает совсем немного энергии. Он позволяет добавить макет и дизайн<br> для наших страниц и обмениваться стилями от элемента к элементу и страницы к странице. Прежде чем мы сможем<br> раскрыть все особенности <font color="orange" >CSS</font>, есть несколько аспектов языка, которые вы должны в полной мере понимать.<br><br>

    Первое что важно знать, как именно отображаются стили. В частности, мы должны знать, как работают разные типы селекторов и как порядок этих селекторов может повлиять на отображение стилей. Мы также хотим понимать несколько основных значений свойств, которые постоянно появляются в <font color="orange" >CSS</font>, в частности те, которые касаются цвета и размера.<br><br>

    Давайте заглянем под капот <font color="orange" >CSS</font>, чтобы точно узнать что происходит.<br><br> 

    <h2>Каскад</h2> 
    Мы начнём разбирать, как именно отображаются стили со взгляда на то, что известно как каскад и изучения несколько примеров каскада в действии. В <font color="orange" >CSS</font> все стили идут каскадом сверху вниз, что позволяет добавлять другой стиль или переписывать его, тем самым таблицы стилей развиваются.<br><br>

    Скажем, к примеру, что мы выбрали все элементы абзаца в верхней части нашего стиля и установили для них цвет фона orange и шрифт размером 24 пикселя. Затем в нижней части нашего стиля мы снова выбираем все элементы абзаца и устанавливаем для них цвет фона green, как показано здесь.<br><br>
        <pre class="code" style="background-color: Ivory; width:92%; border-radius: 10px">
        <code class="language-css" style="text-shadow: none; ">p {
          background: orange;
          font-size: 24px;
      }
      p {
         background: green;
      }</code>  
    </pre> <br>     
      Поскольку селектор абзаца, который устанавливает зелёный цвет фона располагается после селектора абзаца, который задаёт оранжевый цвет фона, он будет иметь приоритет в каскаде. Все абзацы появятся на зелёном фоне. Размер шрифта останется 24 пикселя, потому что второй селектор абзаца не определил новый размер шрифта.<br><br>

    <h2>  Каскадные свойства</h2>
    Каскад работает со свойствами внутри отдельных селекторов. Опять же, скажем, к примеру, что мы выбрали все элементы абзаца и установили для них цвет фона orange. Затем прямо ниже свойства background и его значения мы добавляем ещё одно свойство и значение, которое задаёт цвет фона green, как показано здесь.<br><br>
    <pre class="code" style="background-color: Ivory; width:92%; border-radius: 10px">
        <code class="language-css" style="text-shadow: none; ">p {
          background: orange;
          background: green;
      }</code>  
    </pre> <br>  



    Поскольку объявление зелёного цвета фона написано после объявления оранжевого цвета фона, как и прежде, наши абзацы будут отображаться на зелёном фоне.<br><br>

    Все стили идут каскадом сверху нашей таблицы стилей до её низа. Есть, однако, случаи, когда каскад не так хорошо работает — порой, когда применяются различные типы селекторов и специфичность этих селекторов разбивает каскад. Давайте взглянем.<br><br>

    <h2>Вычисление специфичности</h2>
    Каждый селектор в <font color="orange" >CSS</font> имеет вес специфичности, он вместе с положением в каскаде определяет, как будут отображаться стили.<br><br>

    В уроке 1 «Создание первой веб-страницы» мы говорили о трёх разных видах селекторов: селектор типа, класс и идентификатор. Каждый из этих селекторов имеет различный вес специфичности.<br><br>

    У селектора типа низкий вес специфичности и значение балла 0-0-1. У селектора класса средний вес специфичности и значение балла 0-1-0. Наконец, у идентификаторов высокая специфичность и значение балла 1-0-0. Как мы видим, баллы специфичности вычисляются с помощью трёх колонок. В первой колонке количество идентификаторов, во второй классов, а третья колонка считает селекторы типа.<br><br>

    Важно отметить, что идентификатор имеет больший вес специфичности чем селектор класса, а класс больший вес, чем селектор типа.<br><br>

    <h2>Баллы специфичности</h2>
    Баллы специфичности намеренно разделены дефисом, так как их значения не вычисляются по десятичной системе. У селекторов класса нет 10 баллов, у идентификаторов нет 100 баллов. Вместо этого эти баллы следует читать как 0-1-0 и 1-0-0 соответственно. Мы внимательно рассмотрим, почему эти значения пишутся через дефис в ближайшее время, когда мы станем комбинировать селекторы.<br><br>

    Чем выше вес специфичности селектора, тем больше первенства ему отдаётся при возникновении конфликта стилей. Например, если элемент абзаца выбирается с помощью селектора типа в одном месте и идентификатора в другом, то идентификатор будет иметь приоритет над селектором типа, независимо от того, где идентификатор появляется в каскаде.<br><br>

    <h2><font color="orange" >HTML</font></h2>

    <pre class="code" style="background-color: Ivory; width:92%; border-radius: 10px">
        <code class="language-html" style="text-shadow: none; ">&ltp id="food">...&lt/p></code> 
    </pre> <br>

     <h2><font color="orange" >CSS</font></h2>

    <pre class="code" style="background-color: Ivory; width:92%; border-radius: 10px">
        <code class="language-css" style="text-shadow: none; ">#food {
          background: green;
      }
      p {
          background: orange;
      }</code>  
    </pre> <br>


    Здесь у нас есть элемент абзаца со значением атрибута id — food. В нашем <font color="orange" >CSS</font> этот абзац выбирается двумя различными типами селекторов: один селектор типа, а второй идентификатор. Несмотря на то, что селектор типа указан после идентификатора в каскаде, идентификатор имеет приоритет над селектором типа, потому что он имеет больший вес специфичности, следовательно, абзац появится на зелёном фоне.<br><br>

    Специфичность веса разных типов селекторов невероятно важно помнить. Порой стили не могут появиться на элементах, как предполагалось, вероятно оттого, что специфичность веса наших селекторов нарушила каскад, поэтому наши стили не отображаются должным образом.<br><br>

    Понимание того, как каскад и специфичность работают — это огромное затруднение и мы будем продолжать освещать эту тему. А сейчас давайте посмотрим на то, как стать немного конкретнее и обоснованными с нашими селекторами, путём их комбинации. Имейте в виду, что при комбинации селекторов, мы также меняем их специфичность.<br><br>

    <h2>Комбинация селекторов</h2>
    Пока мы рассмотрели как использовать разные типы селекторов индивидуально, но мы также должны знать, как использовать эти селекторы вместе. Комбинируя селекторы мы можем быть более конкретными в том, какой элемент или группу элементов мы хотели бы выбрать.<br><br>

    Скажем, к примеру, мы хотим выбрать все элементы абзаца, которые находятся внутри элемента со значением атрибута класса hotdog и установить для них цвет фона как brown. Однако, если один из этих абзацев, случаем, содержит значение атрибута класса mustard, мы хотим установить его цвет фона как yellow. Наши <font color="orange" >HTML</font> и <font color="orange" >CSS</font> могут выглядеть следующим образом:<br><br>

    <h2><font color="orange" >HTML</font></h2>

    <pre class="code" style="background-color: Ivory; width:92%; border-radius: 10px">
        <code class="language-html" style="text-shadow: none; ">&ltdiv class="hotdog">
          &ltp>...&lt/p>
          &ltp>...&lt/p>
          &ltp class="mustard">...&lt/p>
      &lt/div></code> 
    </pre> <br>

     <h2><font color="orange" >CSS</font></h2>

    <pre class="code" style="background-color: Ivory; width:92%; border-radius: 10px">
        <code class="language-css" style="text-shadow: none; ">.hotdog p {
          background: brown;
      }
      .hotdog p.mustard {
         background: yellow;
      }</code>  
    </pre> <br>


    Когда селекторы комбинируются они должны читаться справа налево. Самый крайний селектор справа, непосредственно перед открытой скобкой, известен как ключевой селектор. Он определяет, к каким именно элементам будут применяться стили. Любой селектор слева от ключевого будет служить уточнением.<br><br>

    Первый комбинированный селектор выше, .hotdog р, включает в себя два селектора: класс и селектор типа. Эти два селектора разделяются пробелом. Ключевым селектором выступает селектор типа, нацеленный на элементы абзаца. Поскольку этот селектор сочетается с классом hotdog, полный комбинированный селектор выбирает только элементы абзаца, которые находятся внутри элемента с классом hotdog.<br><br>

    Второй селектор выше, .hotdog p.mustard, включает в себя три селектора: два класса и один селектор типа. Единственное различие между вторым и первым селекторами является добавление класса mustard в конце селектора абзаца. Поскольку новый класс mustard находится в правой части комбинированного селектора, то он ключевой, а все отдельные селекторы идущие перед ним теперь уточняющие.<br><br>

    <h2>Пробелы в селекторах</h2>
    В предыдущем комбинированном селекторе, .hotdog p.mustard, есть пробел между классом hotdog и селектором абзаца, но не между селектором абзаца и классом mustard. Использование пробелов и отказ от них — это большая разница в селекторах.<br><br>

    Поскольку нет пробела между селектором абзаца и классом mustard, это значит что будут выбраны только абзацы с классом mustard. Если бы селектор абзаца был удалён, а класс mustard содержал пробелы с двух сторон, то был бы выбран любой элемент с классом mustard, а не только абзацы.<br><br>

    Лучше всего не писать селектор типа перед селектором класса. Как правило, мы хотим выбрать любой элемент с данным классом, а не только один тип элемента. С учётом этого наш новый комбинированный селектор будет лучше писать как .hotdog .mustard.<br><br>

    Читая комбинированный селектор справа налево — он нацелен на абзацы со значением атрибута класса mustard, который располагается внутри элемента с значением атрибута класса hotdog.<br><br>

    Разные типы селекторов могут комбинироваться, чтобы обнаружить любой конкретный элемент на странице. Поскольку мы продолжим писать различные комбинированные селекторы, то увидим их мощь в жизни. Прежде, чем мы это сделаем, давайте взглянем на то, как меняется вес специфичности комбинированных селекторов.<br><br>

    <h2>Специфичность в комбинированных селекторах</h2>
    Вес специфичности комбинированных селекторов может быть вычислен путём подсчёта каждого отдельного типа селектора в их комбинации.<br><br>

    Взглянем на наш комбинированный селектор выше. Первый селектор, .hotdog р, содержит селектор класса и селектор типа. Зная, что баллы класса это 0-1-0, а баллы селектора типа это 0-0-1, суммарные комбинированные баллы будут 0-1-1, это определяется путём суммирования каждого вида селектора.<br><br>

    Второй селектор, .hotdog p.mustard, содержит два селектора класса и один селектор типа. У комбинированного селектора будут баллы 0-2-1. 0 в первой колонке показывает нулевое число идентификаторов, 2 во второй колонке — два селектора класса, а 1 в последней колонке — один селектор типа.<br><br>

    Сравнивая два селектора, у второго селектора с двумя классами заметно более высокое значение веса специфичности и баллов. Как таковой, он будет иметь приоритет в каскаде. Если бы мы перевернули порядок этих селекторов в нашей таблице стилей, поместив более «тяжёлый» селектор выше «лёгкого» селектора, как показано здесь, вывод их стилей не будет затронут, в силу специфичности веса каждого селектора.<br><br>

    <pre class="code" style="background-color: Ivory; width:92%; border-radius: 10px">
        <code class="language-css" style="text-shadow: none; ">.hotdog p.mustard {
          background: yellow;
      }
      .hotdog p {
          background: brown;
      }</code>  
    </pre> <br>


    В общем, мы хотим, чтобы вы всегда держали вес специфичности селекторов в поле зрения. Чем больше растёт вес специфичности, тем более вероятно, что наш каскад сломается.<br><br>

<h2>Разделение стилей по нескольким классам</h2><br>
Одним из способов сохранить низкими веса специфичности наших селекторов является при возможности модульность, передача похожих стилей от элемента к элементу. Один из вариантов модульности — разделение на разные стили с помощью нескольких классов.<br><br>

Элементы в <font color="orange" >HTML</font> могут содержать более одного атрибута class, при этом их значения разделяются пробелами. За счёт этого мы можем применить некоторые стили ко всем элементам одного вида, а другие стили к конкретным элементам этого же вида.<br><br>

Мы можем связать стили, которые хотим постоянно повторять с одним классом и разделить на дополнительные стили с другим классом.<br><br>

Давайте взглянем на кнопки, к примеру. Скажем, мы хотим, чтобы у всех наших кнопок был размер шрифта 16 пикселей, но чтобы цвет фона кнопок мог варьироваться в зависимости от того, где кнопки применяются. Мы можем создать несколько классов и распределить их по элементам, в зависимости от применения желаемых стилей.<br><br>

<h2><font color="orange" >HTML</font></h2>

    <pre class="code" style="background-color: Ivory; width:92%; border-radius: 10px">
        <code class="language-html" style="text-shadow: none; ">&lta class="btn btn-danger">...&lt/a>
      &lta class="btn btn-success">...&lt/a>
      </code> 
    </pre> <br>

    <h2><font color="orange" >CSS</font></h2>

<pre class="code" style="background-color: Ivory; width:92%; border-radius: 10px">
        <code class="language-css" style="text-shadow: none; ">.btn {
          font-size: 16px;
    }
      .btn-danger {
          background: red;
    }
      .btn-success {
      background: green;
    }</code>  
    </pre> <br>

    Здесь вы можете увидеть два элемента ссылок с несколькими значениями атрибутов класса. Первый класс, btn, используется для задания размера шрифта 16 пикселей каждому из элементов. Затем, первый элемент ссылки использует дополнительный класс btn-danger, чтобы применить красный цвет фона, а второй элемент ссылки использует дополнительный класс btn-success, чтобы применять зелёный цвет фона. Наши стили чистые и модульные.<br><br>

Используя несколько классов мы можем делить стили на множество классов по своему желанию, сохраняя наш код компактным с низким весом специфичности. Понимание каскада и вычисление специфичности требует практики, которая занимает время до полного постижения, но в этом мы становимся с каждым уроком всё лучше.<br><br>

<h2>Основные значения свойств <font color="orange" >CSS</font></h2><br>
Мы уже применяли небольшую часть значений основных свойств <font color="orange" >CSS</font>, такие как значения цвета red и green. Вы, возможно, не слишком задумывались об этом, это нормально. Мы теперь потратим немного времени и перейдём к некоторым ранее используемым значениям свойств, а также исследуем часть основных свойств, которые вскоре будем использовать.<br><br>
      </div>
      <a href="#top" class="collapse-btn"><img src="\images\button_up.jpeg" width="50px" height="50px" style="filter: invert(0.99);"> </a>
    </div>






    <div class="info_1">
      <input id="info__body_2" class="info__switch_1" type="checkbox">
      <label id="info__body_2" for="info__body_2" class="info__headline_1">Открываем блочную модель</label>
      <div class="info__body_1">
        Мы познакомились с HTML и <font color="orange" >CSS</font>, знаем как они выглядят и как выполнить некоторые основы. Теперь мы собираемся погрузиться немного глубже и подробно рассмотреть, как элементы отображаются на странице и задаются их размеры.<br><br>

В процессе мы обсудим тему, известную как блочная модель и как она работает с HTML и <font color="orange" >CSS</font>. Мы также рассмотрим несколько новых свойств <font color="orange" >CSS</font> и используем некоторые значения размеров, о которых рассказывали в уроке 3. Давайте начнём.<br><br>

<h2>Как отображаются элементы?</h2><br>
Прежде чем перейти к блочной модели, нам надо понимать, как отображаются элементы. В уроке 2 мы рассмотрели разницу между блочными и строчными элементами. Быстро напомним, что блочные элементы занимают всю доступную ширину независимо от их содержимого и начинаются с новой строки. Строчные элементы занимают ширину, которая требуется для содержимого и выстраиваются на одной строке, друг за другом. Блочные элементы, как правило, используются для больших кусков контента, таких как заголовки и структурные элементы. Строчные элементы, как правило, применяются для маленьких частей содержимого, таких как несколько слов, выделенных жирным или курсивным начертанием.<br><br>

<h2><font color="orange" >Display</font></h2><br>
Как именно отображаются элементы — как блочные или строчные или как-то ещё, определяется свойством display. Каждый элемент содержит значение свойства display по умолчанию, но как и с любым другим значением свойств, это значение может быть переписано. Есть немало значений для свойства display, но наиболее распространённые это block, inline, inline-block и none.<br><br>

Мы можем изменить значение свойства display элемента, выбрав этот элемент в <font color="orange" >CSS</font> и задав новое значение свойства display. Значение block сделает этот элемент блочным.<br><br>


<pre class="code" style="background-color: Ivory; width:92%; border-radius: 10px">
        <code class="language-css" style="text-shadow: none; ">p {
          display: block;
      }</code></pre> <br>

Значение inline сделает этот элемент строчным.<br><br>

<pre class="code" style="background-color: Ivory; width:92%; border-radius: 10px">
        <code class="language-css" style="text-shadow: none; ">p {
          display: inline;
      }</code></pre> <br>


Самое интересное это значение inline-block. Его использование позволит элементу вести себя как блочный, включая все свойства блочной модели (которые мы вскоре рассмотрим). Однако, элемент будет отображаться на строке с другими элементами, а не будет начинаться с новой строки по умолчанию.<br><br>


<pre class="code" style="background-color: Ivory; width:92%; border-radius: 10px">
        <code class="language-css" style="text-shadow: none; ">p {
          display: inline-block;
      }</code></pre> <br>

    <h2>Пространство между строчно-блочными элементами</h2>
Одним из важных отличий строчно-блочных элементов является то, что они не всегда соприкасаются или отображается непосредственно друг за другом. Обычно между двумя элементами будет небольшое пространство. Это пространство, возможно и раздражает, но это нормально. Мы обсудим, почему оно существует и как его убрать в следующем уроке.

В заключение, используя значение none полностью скрываем элемент и отображаем страницу, словно элемента не существует. Любые элементы, вложенные в такой элемент, также будут скрыты.

<pre class="code" style="background-color: Ivory; width:92%; border-radius: 10px">
        <code class="language-css" style="text-shadow: none; ">div {
          display: none;
      }</code></pre> <br>


Знание, как отображаются элементы и как изменить display довольно важно, так как display оказывает влияние на отображение блочной модели. В процессе обсуждения блочной модели мы обязательно взглянем на эти разные последствия и как они могут повлиять на представление элемента.<br><br>

<h2>Что такое блочная модель?</h2><br>
В соответствии с концепцией блочной модели, каждый элемент на странице представляет собой прямоугольный блок и может иметь ширину, высоту, поля, границы и отступы.<br><br>

Это стоит повторить: Каждый элемент на странице представляет собой прямоугольный блок.<br><br>
<img src="/images/boxes.jpeg" width="60%"><br>


Каждый элемент на каждой странице соответствует блочной модели, так что это невероятно важно. Давайте взглянем на неё, наряду с несколькими новыми свойствами <font color="orange" >CSS</font>, чтобы лучше понять, как мы можем с этим работать.<br><br>

<h2>Работа с блочной моделью</h2><br>
Каждый элемент представляет собой прямоугольный блок и есть несколько свойств, которые устанавливают размер этого блока. Внутренность блока определяется шириной и высотой элемента, который может быть задан свойством display, содержимым элемента или свойствами width и height. padding и затем border расширяют размеры блока наружу от ширины и высоты элемента. Наконец, любой указанный margin идёт за пределами рамки.<br><br>

Каждая часть блочной модели соответствует свойству <font color="orange" >CSS</font>: width, height, padding, border и margin.<br><br>

Взглянем на эти свойства внутри некоторого кода:<br><br>

<pre class="code" style="background-color: Ivory; width:92%; border-radius: 10px">
        <code class="language-css" style="text-shadow: none; ">div {
          border: 6px solid #949599;
          height: 100px;
          margin: 20px;
          padding: 20px;
          width: 400px;
      }</code></pre> <br>

В соответствии с блочной моделью общая ширина элемента может быть рассчитана по следующей формуле:<br><br>

<pre class="code" style="background-color: Ivory; width:92%; border-radius: 10px">
        <code class="language-css" style="text-shadow: none; ">margin-right + border-right + padding-right + width + padding-left</code></pre> <br>

Для сравнения, в соответствии с блочной моделью общая высота элемента может быть рассчитана по следующей формуле:<br><br>

<pre class="code" style="background-color: Ivory; width:92%; border-radius: 10px">
        <code class="language-css" style="text-shadow: none; ">margin-top + border-top + padding-top + height + padding-bottom</code></pre> <br>

<img src="/images/box-model.jpeg" width="60%"><br><br>

Используя эти формулы, мы можем найти общую высоту и ширину блока из нашего примера.<br><br>

Ширина: 492px = 20px + 6px + 20px + 400px + 20px + 6px + 20px<br>
Высота: 192px = 20px + 6px + 20px + 100px + 20px + 6px + 20px<br><br>
Блочная модель, без сомнения, одна из наиболее запутанных частей HTML и CSS. Мы устанавливаем значение свойства width как 400 пикселей, но фактическая ширина нашего элемента 492 пикселя. По умолчанию блочная модель коробка аддитивна. Таким образом, для определения фактического размера блока мы должны принять во внимание поля, границы и отступы для всех четырёх сторон блока. Наша ширина включает не только значение свойства width, но и размер левого и правого поля, левую и правую границу, левые и правые отступы.<br><br>

Пока многие из этих свойств не несут большого смысла и это нормально. Для уточнения давайте поближе посмотрим на все эти свойства width, height, padding, border и margin, которые формируют блочную модель.<br><br>

<h2>width и height</h2>
У каждого элемента есть ширина и высота по умолчанию. Эта ширина и высота может быть равна нулю, но браузеры по умолчанию отображают каждый элемент с размером. В зависимости от того, как отображается элемент, ширина и высота по умолчанию может быть соответствующей. Если элемент является ключевым в макете страницы, для него может потребоваться задать определённые значения свойств width и height. В этом случае значения свойств для не строчных элементов могут быть указанными.

<h2>width</h2>
По умолчанию ширина элемента основана на значении display. У блочных элементов ширина по умолчанию 100% и занимает всё доступное горизонтальное пространство. Строчные и строчно-блочные элементы расширяются и сжимаются горизонтально для размещения их содержимого. Строчные элементы не могут иметь фиксированный размер, таким образом, ширина и высота относятся только к не строчным элементам. Чтобы задать определённую ширину для не строчных элементов, используйте свойство width:

<pre class="code" style="background-color: Ivory; width:92%; border-radius: 10px">
        <code class="language-css" style="text-shadow: none; ">div {
            width: 400px;
        }</code></pre> <br>
<h2>height</h2><br> <br>  
Высота элемента по умолчанию определяется его содержимым. Элемент будет расширяться и сжиматься по вертикали при необходимости, чтобы вместить его содержимое. Установить определённую высоту для не строчных элементов можно через свойство height:<br>  <br>  
<pre class="code" style="background-color: Ivory; width:92%; border-radius: 10px">
        <code class="language-css" style="text-shadow: none; ">div {
            height: 100px;
        }</code></pre> <br>
        <h2>  Размеры строчно-блочных элементов</h2><br>  
Пожалуйста, помните, что строчные элементы не принимают свойства width и height и любые их значения. <br> Блочные и строчно-блочные элементы, однако, принимают свойства width и height и соответствующие им значения.<br>  <br>  



      </div>
      <a href="#top" class="collapse-btn_1"><img src="\images\button_up.jpeg" width="50px" height="50px" style="filter: invert(0.99);"> </a>
    </div>














    <div class="info_2">
      <input id="info__body_3" class="info__switch_2" type="checkbox">
      <label id="info__body_3" for="info__body_3" class="info__headline_2">Установка фона и градиента</label>
      <div class="info__body_2">
        Фон оказывает значительное воздействие на дизайн сайта. Он помогает создать впечатляюще выглядящий сайт, установить группирование и определить приоритет, фон также серьёзно влияет на юзабилити сайта.<br> <br>

В CSS фон элемента может быть сплошного цвета, изображением, градиентом или их комбинацией. Когда мы решаем, как реализовать такой фон, то должны понимать, что каждый фон влияет на общий вид нашего сайта.<br> <br>

В этом уроке мы рассмотрим как назначать разные типы фона для элементов, в том числе градиенты. Мы также поиграем с набором свойств CSS3, связанных с фоном.<br> <br>

<h2> Добавление цвета фона </h2><br>
Самый быстрый способ добавить фон к элементу — это установить однотонный фон с помощью свойства background или background-color. Свойство background принимает цвет и изображения в сокращённой форме, в то время как свойство background-color используется строго для установки сплошной фоновой заливки. Оба свойства работают, а какое вы решите использовать зависит от ваших предпочтений, а также ситуации.<br> <br>

<pre class="code" style="background-color: Ivory; width:92%; border-radius: 10px">
        <code class="language-css" style="text-shadow: none; ">div {
            background-color: #b2b2b2;
        }</code></pre> <br>

При добавлении цвета фона у нас есть несколько вариантов значений, которые мы можем использовать. Подобно другим цветовым значениям мы можем выбрать из ключевых слов, шестнадцатеричных кодов и значений RGB, RGBa, HSL и HSLa. Чаще мы встретим шестнадцатеричные значения, однако можем иногда пожелать задействовать RGBa или значения HSLa для прозрачности.<br> <br>  

<h2> Прозрачный фон </h2><br>  
При использовании значения RGBa или HSLa в качестве прозрачного цвета фона хорошей идеей будет обеспечить также запасной цвет, потому что не все браузеры понимают RGBa или HSLa. И когда браузер встречает значение, которое он не распознаёт, то игнорирует его.<br> <br> 

К счастью, есть простой способ обеспечить запасной вариант для фона. CSS каскадирует с верхней части файла до его низа, таким образом, мы можем использовать два свойства background-color в едином наборе правил. Первое свойство background-color будет включать «безопасный» цвет фона в виде шестнадцатеричного значения, а второе свойство background-color будет использовать RGBa или HSLa. При этом, если браузер понимает значение RGBa или HSLa, то отобразит его, а если нет, то вернётся к шестнадцатеричному значению перед ним.<br> <br> 


<pre class="code" style="background-color: Ivory; width:92%; border-radius: 10px">
        <code class="language-css" style="text-shadow: none; ">div {
            background-color: #b2b2b2;
            background-color: rgba(0, 0, 0, .3);
        }</code></pre> <br>


        <h2> Добавление фонового изображения </h2>
Кроме цвета фона элемента мы можем также добавить к нему фоновое изображение. Такие изображения работают аналогично цвету фона, однако предлагают несколько дополнительных свойств для уточнения. Как и прежде, мы можем использовать свойство background с сокращённым значением или свойство background-image напрямую. Независимо от применяемого свойства они требуют указать источник изображения с помощью функции url().<br> <br> 

Значение функции url() будет адресом фоновой картинки и к нему применяются знакомые правила для создания пути гиперссылки. Следите за разными папками и не забудьте показать, где именно находится изображение. Путь помещается внутри скобок и кавычек.<br> <br>

<pre class="code" style="background-color: Ivory; width:92%; border-radius: 10px">
        <code class="language-css" style="text-shadow: none; ">div {
            background-image: url("alert.png");
        }</code></pre> <br>

<h2> Дизайн градиентного фона </h2><br>
Градиентные фоны были введены с CSS3, дизайнеры и фронтенд-разработчики вовсю радовались этому. Хотя градиентные фоны не работают в старых браузерах, они поддерживаются всеми современными браузерами.<br> <br>  

В CSS градиентные фоны рассматриваются как фоновые изображения. Мы можем создать градиент с помощью свойства background или background-image, как обычную фоновую картинку. Значение свойства для градиента меняется в зависимости от того, какой градиент нам бы хотелось — линейный или радиальный.<br> <br>

<h3> Вендорные префиксы для градиента </h3><br>
В уроке 4, «Открываем блочную модель», мы обсуждали добавление вендорных префиксов к новым свойствам или значениям CSS, так что браузеры могут поддерживать недавно разработанные возможности CSS. Градиенты были одними из значений, которые требовали использование префиксов. К счастью, для большинства браузеров отпала необходимость в префиксах для отображения градиентов, тем не менее, всё равно стоит указать префиксы для обеспечения лучшей поддержки.<br> <br>

Сперва мы начнём обсуждать линейные градиенты и включим различные префиксы. После этого в интересах краткости мы опустим префиксы, когда продолжим обсуждать градиенты, в том числе радиальные.<br> <br>

<h3> Линейный градиент </h3><br>
В течение многих лет дизайнеры и разработчики нарезали градиентные изображения, созданные с помощью графических редакторов и применяли к элементам картинки в качестве линейных градиентов. Процесс работал, но отнимал время для реализации и был чрезвычайно негибким. К счастью эти времена ушли и линейные градиенты теперь могут быть заданы в CSS. Если цвет нуждается в изменении, нет необходимости повторно разрезать изображение и загружать его на сервер. Теперь всё что нужно сделать, это быстро изменить значение в CSS. Красота.<br> <br>


<pre class="code" style="background-color: Ivory; width:92%; border-radius: 10px">
        <code class="language-css" style="text-shadow: none; ">div {
            background: #466368;
            background: -webkit-linear-gradient(#648880, #293f50);
            background:    -moz-linear-gradient(#648880, #293f50);
            background:         linear-gradient(#648880, #293f50);
        }</code></pre> <br>



Линейные градиенты определяются с помощью функции linear-gradient() в свойстве background или background-image. Функция linear-gradient() должна включать в себя два значения цвета, первое из которых будет начальным цветов, а второе конечным цветом. Браузер затем обработает переход между двумя цветами.<br> <br>

Перед определением любого градиентного фона мы также вставим свойство background по умолчанию с однотонным цветом. Такой цвет должен быть использован в качестве запасного, если браузер не поддерживает градиент.<br> <br>









      </div>
      <a href="#top" class="collapse-btn_2"><img src="\images\button_up.png" width="50px" height="50px" style="filter: invert(0.99);"> </a>
    </div>
















    <div class="info_3">
      <input id="info__body_4" class="info__switch_3" type="checkbox">
      <label id="info__body_4" for="info__body_4" class="info__headline_3">margin и padding</label>
      <div class="info__body_3">
        

В зависимости от элемента, браузеры могут применять отступы и поля по умолчанию для элемента, чтобы помочь с удобочитаемостью. Мы, как правило, видим это на текстовых элементах. Поля и отступы по умолчанию для этих элементов могут отличаться от браузера к браузеру и от элемента к элементу. В уроке 1 мы обсуждали использование сброса CSS чтобы все эти значения по умолчанию стали нулевыми. Это позволяет нам работать с нуля и задать собственные значения.<br> <br>  

<h2>margin</h2><br> 
Свойство margin позволяет нам установить пространство, которое окружает элемент. margin находятся за пределами любых границ и полностью прозрачны в цвете. Они могут использоваться для позиционирования элементов в конкретном месте на странице или добавить пустое пространство, сохраняя все другие элементы на безопасном расстоянии. Вот свойство margin в действии:<br> <br> 


<pre class="code" style="background-color: Ivory; width:92%; border-radius: 10px">
        <code class="language-css" style="text-shadow: none; ">div {
            margin: 20px;
        }</code></pre> <br>

          Одной из причуд margin являются вертикальные значения, сверху и снизу, они не применяются к строчным элементам, но применяются к блочным и строчно-блочным элементам.<br> <br>  

<h2>padding</h2>
Свойство padding очень похоже на свойство margin, однако располагается внутри границ элемента. Свойство padding используется, чтобы задать пространство непосредственно внутри элемента. Вот код:<br> <br>  

<pre class="code" style="background-color: Ivory; width:92%; border-radius: 10px">
        <code class="language-css" style="text-shadow: none; ">div {
            padding: 20px;
        }</code></pre> <br>

Свойство padding в отличие от margin работает вертикально для строчных элементов. Вертикальный padding может сливаться со строкой выше или ниже данного элемента, но будет отображаться.<br> <br> 

<h2>margin и padding для строчных элементов</h2><br>  
Строчные элементы ведут себя немного по-другому, чем блочные и строчно-блочные элементы, когда дело доходит до отступов и полей. Для строчных элементов margin работает только горизонтально — слева и справа от элементов. padding работает на всех четырёх сторонах строчных элементов, однако вертикальные поля сверху и снизу могут выходить за пределы строки выше и ниже элемента.<br>  <br>  

Отступы и поля работают как обычно для блочных и строчно-блочных элементов.<br> <br>  















      </div>
      <a href="#top" class="collapse-btn_3"><img src="\images\button_up.png" width="50px" height="50px" style="filter: invert(0.99);"> </a>
    </div>

    <div class="info_4">
      <input id="info__body_5" class="info__switch_4" type="checkbox">
      <label id="info__body_5" for="info__body_5" class="info__headline_4">Цвет отступов и полей</label>
      <div class="info__body_4">
        
<h2> Цвет отступов и полей </h2><br>  
Свойства margin и padding полностью прозрачны и не принимают какие-либо цветовые значения. Но будучи прозрачными они показывают цвет фона связанных элементов. Для margin мы видим цвет фона родительского элемента, а для padding видим цвет фона элемента, к которому применяется padding.<br>  <br>  

<h2>  Границы</h2><br>  
Границы располагаются между отступами и полями, создавая рамку вокруг элемента. Для свойства border требуется три значения: ширина, стиль и цвет. Сокращённая запись для border задаётся этом же порядке — ширина, стиль, цвет. В обычной записи эти три значения могут быть разбиты по свойствам border-width, border-style и border-color. Обычная запись полезна для изменения или переписывания отдельного значения границы.<br>  <br> 

Ширина и цвет границ могут быть определены с помощью обычных единиц размера и цвета CSS, как описано в уроке 3.<br>  <br> 

У границ может быть различный внешний вид. Наиболее распространённые значения solid, double, dashed, dotted и none, но есть и несколько других на выбор.<br>  <br> 

Вот код для сплошной серой границы толщиной 6 пикселей для всех четырёх сторон < div >:<br>  <br> 

<pre class="code" style="background-color: Ivory; width:92%; border-radius: 10px">
        <code class="language-css" style="text-shadow: none; ">div {    
            border: 6px solid #949599;
        }</code></pre> <br>
        <img src="/images/boxes2.jpeg" width=" 60%">


<h2>Радиус границы  </h2><br> 
Пока мы рассматриваем границы и их разные свойств, нам нужно изучить свойство border-radius, которое позволяет нам закруглять углы элемента.<br>  <br>  

Свойство border-radius принимает единицы размера, в том числе проценты и пиксели, которые определяют радиус скругления углов элемента. Единственное значение закругляет все четыре угла элемента в равной степени; два значения закругляют левый верхний/правый нижний и правый верхний/левый нижний углы в таком порядке; четыре значения закругляют левый верхний, правый верхний, правый нижний и левый нижний углы в таком порядке.<br>  <br> 

При рассмотрении порядка, когда несколько значений применяются к свойству border-radius (заодно к margin и padding), помните, что они идут по часовой стрелке, начиная с левого верхнего угла элемента.<br>  <br> 

<pre class="code" style="background-color: Ivory; width:92%; border-radius: 10px">
        <code class="language-css" style="text-shadow: none; ">div {    
            border-radius: 5px;
        }</code></pre> <br>


      </div>
      
</div>
<div class="footer">
  <div class="futer_logo"> 
    <hr class="cherta"><div class="logo1"><font color="orange" ><\> Html</font>School</div><hr class="cherta">
  </div>
  <div class="footer2">
      <div class="our_place">Нижнекамск, пр-т Химиков 29
            </div>
            <div class="data">2024 © Все права защищены 
      <p>ЛЮБАЯ ИНФОРМАЦИЯ, ПРЕДСТАВЛЕННАЯ НА ДАННОМ САЙТЕ, НОСИТ ИСКЛЮЧИТЕЛЬНО ИНФОРМАЦИОННЫЙ ХАРАКТЕР И НИ ПРИ КАКИХ УСЛОВИЯХ НЕ ЯВЛЯЕТСЯ ПУБЛИЧНОЙ ОФЕРТОЙ, ОПРЕДЕЛЯЕМОЙ ПОЛОЖЕНИЯМИ СТАТЬИ 437 ГК РФ.</p></div>
      
  </div>
</body>
</html>
